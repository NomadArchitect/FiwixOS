diff -ruN coreutils-9.1/gnulib-tests/inet_pton.c coreutils-9.1.new/gnulib-tests/inet_pton.c
--- coreutils-9.1/gnulib-tests/inet_pton.c	2022-04-08 13:22:26.000000000 +0200
+++ coreutils-9.1.new/gnulib-tests/inet_pton.c	2023-09-09 17:05:59.000000000 +0200
@@ -32,6 +32,8 @@
  * SOFTWARE.
  */
 
+#ifndef __fiwix__
+
 #include <config.h>
 
 /* Specification.  */
@@ -266,3 +268,5 @@
 # endif
 
 #endif
+
+#endif /* ! __fiwix__ */
diff -ruN coreutils-9.1/lib/getaddrinfo.c coreutils-9.1.new/lib/getaddrinfo.c
--- coreutils-9.1/lib/getaddrinfo.c	2022-04-08 13:22:26.000000000 +0200
+++ coreutils-9.1.new/lib/getaddrinfo.c	2023-09-09 17:06:25.000000000 +0200
@@ -15,6 +15,8 @@
    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
+#ifndef __fiwix__
+
 /* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc
    optimizes away the sa == NULL test below.  */
 #define _GL_ARG_NONNULL(params)
@@ -503,3 +505,5 @@
 }
 
 #endif
+
+#endif /* ! __fiwix__ */
diff -ruN coreutils-9.1/lib/mountlist.c coreutils-9.1.new/lib/mountlist.c
--- coreutils-9.1/lib/mountlist.c	2022-04-08 13:22:26.000000000 +0200
+++ coreutils-9.1.new/lib/mountlist.c	2023-09-09 17:10:05.000000000 +0200
@@ -381,7 +381,7 @@
   /* GNU/Linux allows file system implementations to define their own
      meaning for "dev=" mount options, so don't trust the meaning
      here.  */
-# ifndef __linux__
+# if !defined __linux__ && !defined __fiwix__
 
   static char const dev_pattern[] = ",dev=";
   char const *devopt = strstr (mount_options, dev_pattern);
@@ -407,7 +407,7 @@
 
 #endif
 
-#if defined MOUNTED_GETMNTENT1 && (defined __linux__ || defined __ANDROID__) /* GNU/Linux, Android */
+#if defined MOUNTED_GETMNTENT1 && (defined __linux__ || defined __ANDROID__ || defined __fiwix__) /* GNU/Linux, Android, Fiwix */
 
 /* Unescape the paths in mount tables.
    STR is updated in place.  */
@@ -465,7 +465,7 @@
   {
     FILE *fp;
 
-# if defined __linux__ || defined __ANDROID__
+# if defined __linux__ || defined __ANDROID__ || defined __fiwix__
     /* Try parsing mountinfo first, as that make device IDs available.
        Note we could use libmount routines to simplify this parsing a little
        (and that code is in previous versions of this function), however
diff -ruN coreutils-9.1/lib/sys_select.in.h coreutils-9.1.new/lib/sys_select.in.h
--- coreutils-9.1/lib/sys_select.in.h	2022-04-08 13:22:26.000000000 +0200
+++ coreutils-9.1.new/lib/sys_select.in.h	2023-09-09 17:10:52.000000000 +0200
@@ -84,9 +84,11 @@
    in <sys/time.h>.
    But avoid namespace pollution on glibc systems and "unknown type
    name" problems on Cygwin.  */
+/*
 # if !(defined __GLIBC__ || defined __CYGWIN__)
 #  include <sys/time.h>
 # endif
+*/
 
 /* On AIX 7 and Solaris 10, <sys/select.h> provides an FD_ZERO implementation
    that relies on memset(), but without including <string.h>.
diff -ruN coreutils-9.1/man/su.1 coreutils-9.1.new/man/su.1
--- coreutils-9.1/man/su.1	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-9.1.new/man/su.1	2023-09-09 17:12:57.000000000 +0200
@@ -0,0 +1,65 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.35.
+.TH SU "1" "May 2012" "GNU coreutils 8.17" "User Commands"
+.SH NAME
+su \- run a shell with substitute user and group IDs
+.SH SYNOPSIS
+.B su
+[\fIOPTION\fR]... [\fI-\fR] [\fIUSER \fR[\fIARG\fR]...]
+.SH DESCRIPTION
+.\" Add any additional description here
+.PP
+Change the effective user id and group id to that of USER.
+.TP
+\-, \fB\-l\fR, \fB\-\-login\fR
+make the shell a login shell
+.TP
+\fB\-c\fR, \fB\-\-command\fR=\fICOMMAND\fR
+pass a single COMMAND to the shell with \fB\-c\fR
+.TP
+\fB\-f\fR, \fB\-\-fast\fR
+pass \fB\-f\fR to the shell (for csh or tcsh)
+.TP
+\fB\-m\fR, \fB\-\-preserve\-environment\fR
+do not reset environment variables
+.TP
+\fB\-p\fR
+same as \fB\-m\fR
+.TP
+\fB\-s\fR, \fB\-\-shell\fR=\fISHELL\fR
+run SHELL if /etc/shells allows it
+.TP
+\fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-\-version\fR
+output version information and exit
+.PP
+A mere \- implies \fB\-l\fR.   If USER not given, assume root.
+.SH AUTHOR
+Written by David MacKenzie.
+.SH "REPORTING BUGS"
+Report su bugs to bug\-coreutils@gnu.org
+.br
+GNU coreutils home page: <http://www.gnu.org/software/coreutils/>
+.br
+General help using GNU software: <http://www.gnu.org/gethelp/>
+.br
+Report su translation bugs to <http://translationproject.org/team/>
+.SH COPYRIGHT
+Copyright \(co 2012 Free Software Foundation, Inc.
+License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
+.br
+This is free software: you are free to change and redistribute it.
+There is NO WARRANTY, to the extent permitted by law.
+.SH "SEE ALSO"
+The full documentation for
+.B su
+is maintained as a Texinfo manual.  If the
+.B info
+and
+.B su
+programs are properly installed at your site, the command
+.IP
+.B info coreutils \(aqsu invocation\(aq
+.PP
+should give you access to the complete manual.
diff -ruN coreutils-9.1/src/mknod.c coreutils-9.1.new/src/mknod.c
--- coreutils-9.1/src/mknod.c	2022-04-08 13:22:18.000000000 +0200
+++ coreutils-9.1.new/src/mknod.c	2023-09-09 17:13:25.000000000 +0200
@@ -31,6 +31,8 @@
 #include "smack.h"
 #include "xstrtol.h"
 
+#include <sys/sysmacros.h>	/* needed for makedev() */
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "mknod"
 
diff -ruN coreutils-9.1/src/pinky.c coreutils-9.1.new/src/pinky.c
--- coreutils-9.1/src/pinky.c	2022-04-08 13:22:18.000000000 +0200
+++ coreutils-9.1.new/src/pinky.c	2023-09-09 17:13:40.000000000 +0200
@@ -38,6 +38,8 @@
   proper_name ("David MacKenzie"), \
   proper_name ("Kaveh Ghazi")
 
+#undef HAVE_UT_HOST	/* needed for Fiwix */
+
 /* If true, display the hours:minutes since each user has touched
    the keyboard, or blank if within the last minute, or days followed
    by a 'd' if not within the last day. */
diff -ruN coreutils-9.1/src/sort.c coreutils-9.1.new/src/sort.c
--- coreutils-9.1/src/sort.c	2022-04-08 13:22:18.000000000 +0200
+++ coreutils-9.1.new/src/sort.c	2023-09-09 17:16:12.000000000 +0200
@@ -83,6 +83,10 @@
 # endif
 #endif
 
+#ifdef __fiwix__
+# define pthread_sigmask(how, set, oset) sigprocmask (how, set, oset)
+#endif
+
 #if !defined OPEN_MAX && defined NR_OPEN
 # define OPEN_MAX NR_OPEN
 #endif
@@ -252,9 +256,6 @@
 struct merge_node_queue
 {
   struct heap *priority_queue;  /* Priority queue of merge tree nodes. */
-  pthread_mutex_t mutex;        /* Lock for queue operations. */
-  pthread_cond_t cond;          /* Conditional wait for empty queue to populate
-                                   when popping. */
 };
 
 /* Used to implement --unique (-u).  */
@@ -3349,7 +3350,6 @@
   root->parent = NULL;
   root->level = MERGE_END;
   root->queued = false;
-  pthread_mutex_init (&root->lock, NULL);
 
   init_node (root, root + 1, dest, nthreads, nlines, false);
   return merge_tree;
@@ -3364,7 +3364,6 @@
 
   while (n_nodes--)
     {
-      pthread_mutex_destroy (&node->lock);
       node++;
     }
 
@@ -3400,7 +3399,6 @@
   node->parent = parent;
   node->level = parent->level + 1;
   node->queued = false;
-  pthread_mutex_init (&node->lock, NULL);
 
   if (nthreads > 1)
     {
@@ -3439,7 +3437,6 @@
 static inline void
 lock_node (struct merge_node *node)
 {
-  pthread_mutex_lock (&node->lock);
 }
 
 /* Unlock a merge tree NODE. */
@@ -3447,7 +3444,6 @@
 static inline void
 unlock_node (struct merge_node *node)
 {
-  pthread_mutex_unlock (&node->lock);
 }
 
 /* Destroy merge QUEUE. */
@@ -3456,8 +3452,6 @@
 queue_destroy (struct merge_node_queue *queue)
 {
   heap_free (queue->priority_queue);
-  pthread_cond_destroy (&queue->cond);
-  pthread_mutex_destroy (&queue->mutex);
 }
 
 /* Initialize merge QUEUE, allocating space suitable for a maximum of
@@ -3470,8 +3464,6 @@
      time, the heap should accommodate all of them.  Counting a NULL
      dummy head for the heap, reserve 2 * NTHREADS nodes.  */
   queue->priority_queue = heap_alloc (compare_nodes, 2 * nthreads);
-  pthread_mutex_init (&queue->mutex, NULL);
-  pthread_cond_init (&queue->cond, NULL);
 }
 
 /* Insert NODE into QUEUE.  The caller either holds a lock on NODE, or
@@ -3480,11 +3472,8 @@
 static void
 queue_insert (struct merge_node_queue *queue, struct merge_node *node)
 {
-  pthread_mutex_lock (&queue->mutex);
   heap_insert (queue->priority_queue, node);
   node->queued = true;
-  pthread_cond_signal (&queue->cond);
-  pthread_mutex_unlock (&queue->mutex);
 }
 
 /* Pop the top node off the priority QUEUE, lock the node, return it.  */
@@ -3493,10 +3482,7 @@
 queue_pop (struct merge_node_queue *queue)
 {
   struct merge_node *node;
-  pthread_mutex_lock (&queue->mutex);
-  while (! (node = heap_remove_top (queue->priority_queue)))
-    pthread_cond_wait (&queue->cond, &queue->mutex);
-  pthread_mutex_unlock (&queue->mutex);
+  while (! (node = heap_remove_top (queue->priority_queue)));
   lock_node (node);
   node->queued = false;
   return node;
@@ -3741,6 +3727,7 @@
   struct thread_args args = {lines, lo_threads, total_lines,
                              node->lo_child, queue, tfp, temp_output};
 
+/*
   if (nthreads > 1 && SUBTHREAD_LINES_HEURISTIC <= nlines
       && pthread_create (&thread, NULL, sortlines_thread, &args) == 0)
     {
@@ -3750,6 +3737,7 @@
     }
   else
     {
+*/
       /* Nthreads = 1, this is a leaf NODE, or pthread_create failed.
          Sort with 1 thread. */
       size_t nlo = node->nlo;
@@ -3769,7 +3757,9 @@
       queue_insert (queue, node);
       merge_loop (queue, total_lines, tfp, temp_output);
     }
+/*
 }
+*/
 
 /* Scan through FILES[NTEMPS .. NFILES-1] looking for files that are
    the same as OUTFILE.  If found, replace each with the same
diff -ruN coreutils-9.1/src/su.c coreutils-9.1.new/src/su.c
--- coreutils-9.1/src/su.c	1970-01-01 01:00:00.000000000 +0100
+++ coreutils-9.1.new/src/su.c	2023-09-09 17:16:26.000000000 +0200
@@ -0,0 +1,520 @@
+/* su for GNU.  Run a shell with substitute user and group IDs.
+   Copyright (C) 1992-2012 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Run a shell with the real and effective UID and GID and groups
+   of USER, default 'root'.
+
+   The shell run is taken from USER's password entry, /bin/sh if
+   none is specified there.  If the account has a password, su
+   prompts for a password unless run by a user with real UID 0.
+
+   Does not change the current directory.
+   Sets 'HOME' and 'SHELL' from the password entry for USER, and if
+   USER is not root, sets 'USER' and 'LOGNAME' to USER.
+   The subshell is not a login shell.
+
+   If one or more ARGs are given, they are passed as additional
+   arguments to the subshell.
+
+   Does not handle /bin/sh or other shells specially
+   (setting argv[0] to "-su", passing -c only to certain shells, etc.).
+   I don't see the point in doing that, and it's ugly.
+
+   This program intentionally does not support a "wheel group" that
+   restricts who can su to UID 0 accounts.  RMS considers that to
+   be fascist.
+
+   Compile-time options:
+   -DSYSLOG_SUCCESS	Log successful su's (by default, to root) with syslog.
+   -DSYSLOG_FAILURE	Log failed su's (by default, to root) with syslog.
+
+   -DSYSLOG_NON_ROOT	Log all su's, not just those to root (UID 0).
+   Never logs attempted su's to nonexistent accounts.
+
+   Written by David MacKenzie <djm@gnu.ai.mit.edu>.  */
+
+#include <config.h>
+#include <stdio.h>
+#include <getopt.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <grp.h>
+
+#include "system.h"
+#include "getpass.h"
+
+#if HAVE_SYSLOG_H && HAVE_SYSLOG
+# include <syslog.h>
+#else
+# undef SYSLOG_SUCCESS
+# undef SYSLOG_FAILURE
+# undef SYSLOG_NON_ROOT
+#endif
+
+#if HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+
+#ifndef HAVE_ENDGRENT
+# define endgrent() ((void) 0)
+#endif
+
+#ifndef HAVE_ENDPWENT
+# define endpwent() ((void) 0)
+#endif
+
+#if HAVE_SHADOW_H
+# include <shadow.h>
+#endif
+
+#include "error.h"
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "su"
+
+#define AUTHORS proper_name ("David MacKenzie")
+
+#if HAVE_PATHS_H
+# include <paths.h>
+#endif
+
+/* The default PATH for simulated logins to non-superuser accounts.  */
+#ifdef _PATH_DEFPATH
+# define DEFAULT_LOGIN_PATH _PATH_DEFPATH
+#else
+# define DEFAULT_LOGIN_PATH ":/usr/ucb:/bin:/usr/bin"
+#endif
+
+/* The default PATH for simulated logins to superuser accounts.  */
+#ifdef _PATH_DEFPATH_ROOT
+# define DEFAULT_ROOT_LOGIN_PATH _PATH_DEFPATH_ROOT
+#else
+# define DEFAULT_ROOT_LOGIN_PATH "/usr/ucb:/bin:/usr/bin:/etc"
+#endif
+
+/* The shell to run if none is given in the user's passwd entry.  */
+#define DEFAULT_SHELL "/bin/sh"
+
+/* The user to become if none is specified.  */
+#define DEFAULT_USER "root"
+
+char *crypt (char const *key, char const *salt);
+
+static void run_shell (char const *, char const *, char **, size_t)
+     _Noreturn;
+
+/* If true, pass the '-f' option to the subshell.  */
+static bool fast_startup;
+
+/* If true, simulate a login instead of just starting a shell.  */
+static bool simulate_login;
+
+/* If true, change some environment vars to indicate the user su'd to.  */
+static bool change_environment;
+
+static struct option const longopts[] =
+{
+  {"command", required_argument, NULL, 'c'},
+  {"fast", no_argument, NULL, 'f'},
+  {"login", no_argument, NULL, 'l'},
+  {"preserve-environment", no_argument, NULL, 'p'},
+  {"shell", required_argument, NULL, 's'},
+  {GETOPT_HELP_OPTION_DECL},
+  {GETOPT_VERSION_OPTION_DECL},
+  {NULL, 0, NULL, 0}
+};
+
+/* Add NAME=VAL to the environment, checking for out of memory errors.  */
+
+static void
+xsetenv (char const *name, char const *val)
+{
+  size_t namelen = strlen (name);
+  size_t vallen = strlen (val);
+  char *string = xmalloc (namelen + 1 + vallen + 1);
+  strcpy (string, name);
+  string[namelen] = '=';
+  strcpy (string + namelen + 1, val);
+  if (putenv (string) != 0)
+    xalloc_die ();
+}
+
+#if defined SYSLOG_SUCCESS || defined SYSLOG_FAILURE
+/* Log the fact that someone has run su to the user given by PW;
+   if SUCCESSFUL is true, they gave the correct password, etc.  */
+
+static void
+log_su (struct passwd const *pw, bool successful)
+{
+  const char *new_user, *old_user, *tty;
+
+# ifndef SYSLOG_NON_ROOT
+  if (pw->pw_uid)
+    return;
+# endif
+  new_user = pw->pw_name;
+  /* The utmp entry (via getlogin) is probably the best way to identify
+     the user, especially if someone su's from a su-shell.  */
+  old_user = getlogin ();
+  if (!old_user)
+    {
+      /* getlogin can fail -- usually due to lack of utmp entry.
+         Resort to getpwuid.  */
+      errno = 0;
+      uid_t ruid = getuid ();
+      uid_t NO_UID = -1;
+      struct passwd *pwd = (ruid == NO_UID && errno ? NULL : getpwuid (ruid));
+      old_user = (pwd ? pwd->pw_name : "");
+    }
+  tty = ttyname (STDERR_FILENO);
+  if (!tty)
+    tty = "none";
+  /* 4.2BSD openlog doesn't have the third parameter.  */
+  openlog (last_component (program_name), 0
+# ifdef LOG_AUTH
+           , LOG_AUTH
+# endif
+           );
+  syslog (LOG_NOTICE,
+# ifdef SYSLOG_NON_ROOT
+          "%s(to %s) %s on %s",
+# else
+          "%s%s on %s",
+# endif
+          successful ? "" : "FAILED SU ",
+# ifdef SYSLOG_NON_ROOT
+          new_user,
+# endif
+          old_user, tty);
+  closelog ();
+}
+#endif
+
+/* Ask the user for a password.
+   Return true if the user gives the correct password for entry PW,
+   false if not.  Return true without asking for a password if run by UID 0
+   or if PW has an empty password.  */
+
+static bool
+correct_password (const struct passwd *pw)
+{
+  char *unencrypted, *encrypted, *correct;
+#if HAVE_GETSPNAM && HAVE_STRUCT_SPWD_SP_PWDP
+  /* Shadow passwd stuff for SVR3 and maybe other systems.  */
+  struct spwd *sp = getspnam (pw->pw_name);
+
+  endspent ();
+  if (sp)
+    correct = sp->sp_pwdp;
+  else
+#endif
+    correct = pw->pw_passwd;
+
+  if (getuid () == 0 || !correct || correct[0] == '\0')
+    return true;
+
+  unencrypted = getpass (_("Password:"));
+  if (!unencrypted)
+    {
+      error (0, 0, _("getpass: cannot open /dev/tty"));
+      return false;
+    }
+  encrypted = crypt (unencrypted, correct);
+  memset (unencrypted, 0, strlen (unencrypted));
+  return STREQ (encrypted, correct);
+}
+
+/* Update 'environ' for the new shell based on PW, with SHELL being
+   the value for the SHELL environment variable.  */
+
+static void
+modify_environment (const struct passwd *pw, const char *shell)
+{
+  if (simulate_login)
+    {
+      /* Leave TERM unchanged.  Set HOME, SHELL, USER, LOGNAME, PATH.
+         Unset all other environment variables.  */
+      char const *term = getenv ("TERM");
+      if (term)
+        term = xstrdup (term);
+      environ = xmalloc ((6 + !!term) * sizeof (char *));
+      environ[0] = NULL;
+      if (term)
+        xsetenv ("TERM", term);
+      xsetenv ("HOME", pw->pw_dir);
+      xsetenv ("SHELL", shell);
+      xsetenv ("USER", pw->pw_name);
+      xsetenv ("LOGNAME", pw->pw_name);
+      xsetenv ("PATH", (pw->pw_uid
+                        ? DEFAULT_LOGIN_PATH
+                        : DEFAULT_ROOT_LOGIN_PATH));
+    }
+  else
+    {
+      /* Set HOME, SHELL, and if not becoming a super-user,
+         USER and LOGNAME.  */
+      if (change_environment)
+        {
+          xsetenv ("HOME", pw->pw_dir);
+          xsetenv ("SHELL", shell);
+          if (pw->pw_uid)
+            {
+              xsetenv ("USER", pw->pw_name);
+              xsetenv ("LOGNAME", pw->pw_name);
+            }
+        }
+    }
+}
+
+/* Become the user and group(s) specified by PW.  */
+
+static void
+change_identity (const struct passwd *pw)
+{
+#ifdef HAVE_INITGROUPS
+  errno = 0;
+  if (initgroups (pw->pw_name, pw->pw_gid) == -1)
+    error (EXIT_CANCELED, errno, _("cannot set groups"));
+  endgrent ();
+#endif
+  if (setgid (pw->pw_gid))
+    error (EXIT_CANCELED, errno, _("cannot set group id"));
+  if (setuid (pw->pw_uid))
+    error (EXIT_CANCELED, errno, _("cannot set user id"));
+}
+
+/* Run SHELL, or DEFAULT_SHELL if SHELL is empty.
+   If COMMAND is nonzero, pass it to the shell with the -c option.
+   Pass ADDITIONAL_ARGS to the shell as more arguments; there
+   are N_ADDITIONAL_ARGS extra arguments.  */
+
+static void
+run_shell (char const *shell, char const *command, char **additional_args,
+           size_t n_additional_args)
+{
+  size_t n_args = 1 + fast_startup + 2 * !!command + n_additional_args + 1;
+  char const **args = xnmalloc (n_args, sizeof *args);
+  size_t argno = 1;
+
+  if (simulate_login)
+    {
+      char *arg0;
+      char *shell_basename;
+
+      shell_basename = last_component (shell);
+      arg0 = xmalloc (strlen (shell_basename) + 2);
+      arg0[0] = '-';
+      strcpy (arg0 + 1, shell_basename);
+      args[0] = arg0;
+    }
+  else
+    args[0] = last_component (shell);
+  if (fast_startup)
+    args[argno++] = "-f";
+  if (command)
+    {
+      args[argno++] = "-c";
+      args[argno++] = command;
+    }
+  memcpy (args + argno, additional_args, n_additional_args * sizeof *args);
+  args[argno + n_additional_args] = NULL;
+  execv (shell, (char **) args);
+
+  {
+    int exit_status = (errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE);
+    error (0, errno, "%s", shell);
+    exit (exit_status);
+  }
+}
+
+/* Return true if SHELL is a restricted shell (one not returned by
+   getusershell), else false, meaning it is a standard shell.  */
+
+static bool
+restricted_shell (const char *shell)
+{
+  char *line;
+
+  setusershell ();
+  while ((line = getusershell ()) != NULL)
+    {
+      if (*line != '#' && STREQ (line, shell))
+        {
+          endusershell ();
+          return false;
+        }
+    }
+  endusershell ();
+  return true;
+}
+
+void
+usage (int status)
+{
+  if (status != EXIT_SUCCESS)
+    emit_try_help ();
+  else
+    {
+      printf (_("Usage: %s [OPTION]... [-] [USER [ARG]...]\n"), program_name);
+      fputs (_("\
+Change the effective user id and group id to that of USER.\n\
+\n\
+  -, -l, --login               make the shell a login shell\n\
+  -c, --command=COMMAND        pass a single COMMAND to the shell with -c\n\
+  -f, --fast                   pass -f to the shell (for csh or tcsh)\n\
+  -m, --preserve-environment   do not reset environment variables\n\
+  -p                           same as -m\n\
+  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n\
+"), stdout);
+      fputs (HELP_OPTION_DESCRIPTION, stdout);
+      fputs (VERSION_OPTION_DESCRIPTION, stdout);
+      fputs (_("\
+\n\
+A mere - implies -l.   If USER not given, assume root.\n\
+"), stdout);
+      emit_ancillary_info (PROGRAM_NAME);
+    }
+  exit (status);
+}
+
+int
+main (int argc, char **argv)
+{
+  int optc;
+  const char *new_user = DEFAULT_USER;
+  char *command = NULL;
+  char *shell = NULL;
+  struct passwd *pw;
+  struct passwd pw_copy;
+
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+
+  initialize_exit_failure (EXIT_CANCELED);
+  atexit (close_stdout);
+
+  fast_startup = false;
+  simulate_login = false;
+  change_environment = true;
+
+  while ((optc = getopt_long (argc, argv, "c:flmps:", longopts, NULL)) != -1)
+    {
+      switch (optc)
+        {
+        case 'c':
+          command = optarg;
+          break;
+
+        case 'f':
+          fast_startup = true;
+          break;
+
+        case 'l':
+          simulate_login = true;
+          break;
+
+        case 'm':
+        case 'p':
+          change_environment = false;
+          break;
+
+        case 's':
+          shell = optarg;
+          break;
+
+        case_GETOPT_HELP_CHAR;
+
+        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
+
+        default:
+          usage (EXIT_CANCELED);
+        }
+    }
+
+  if (optind < argc && STREQ (argv[optind], "-"))
+    {
+      simulate_login = true;
+      ++optind;
+    }
+  if (optind < argc)
+    new_user = argv[optind++];
+
+  pw = getpwnam (new_user);
+  if (! (pw && pw->pw_name && pw->pw_name[0] && pw->pw_dir && pw->pw_dir[0]
+         && pw->pw_passwd))
+    error (EXIT_CANCELED, 0, _("user %s does not exist"), new_user);
+
+  /* Make a copy of the password information and point pw at the local
+     copy instead.  Otherwise, some systems (e.g. GNU/Linux) would clobber
+     the static data through the getlogin call from log_su.
+     Also, make sure pw->pw_shell is a nonempty string.
+     It may be NULL when NEW_USER is a username that is retrieved via NIS (YP),
+     but that doesn't have a default shell listed.  */
+  pw_copy = *pw;
+  pw = &pw_copy;
+  pw->pw_name = xstrdup (pw->pw_name);
+  pw->pw_passwd = xstrdup (pw->pw_passwd);
+  pw->pw_dir = xstrdup (pw->pw_dir);
+  pw->pw_shell = xstrdup (pw->pw_shell && pw->pw_shell[0]
+                          ? pw->pw_shell
+                          : DEFAULT_SHELL);
+  endpwent ();
+
+  if (!correct_password (pw))
+    {
+#ifdef SYSLOG_FAILURE
+      log_su (pw, false);
+#endif
+      error (EXIT_CANCELED, 0, _("incorrect password"));
+    }
+#ifdef SYSLOG_SUCCESS
+  else
+    {
+      log_su (pw, true);
+    }
+#endif
+
+  if (!shell && !change_environment)
+    shell = getenv ("SHELL");
+  if (shell && getuid () != 0 && restricted_shell (pw->pw_shell))
+    {
+      /* The user being su'd to has a nonstandard shell, and so is
+         probably a uucp account or has restricted access.  Don't
+         compromise the account by allowing access with a standard
+         shell.  */
+      error (0, 0, _("using restricted shell %s"), pw->pw_shell);
+      shell = NULL;
+    }
+  shell = xstrdup (shell ? shell : pw->pw_shell);
+  modify_environment (pw, shell);
+
+  change_identity (pw);
+  if (simulate_login && chdir (pw->pw_dir) != 0)
+    error (0, errno, _("warning: cannot change directory to %s"), pw->pw_dir);
+
+  /* error() flushes stderr, but does not check for write failure.
+     Normally, we would catch this via our atexit() hook of
+     close_stdout, but execv() gets in the way.  If stderr
+     encountered a write failure, there is no need to try calling
+     error() again.  */
+  if (ferror (stderr))
+    exit (EXIT_CANCELED);
+
+  run_shell (shell, command, argv + optind, MAX (0, argc - optind));
+}
diff -ruN coreutils-9.1/src/who.c coreutils-9.1.new/src/who.c
--- coreutils-9.1/src/who.c	2022-04-08 13:22:18.000000000 +0200
+++ coreutils-9.1.new/src/who.c	2023-09-09 17:16:48.000000000 +0200
@@ -98,6 +98,8 @@
 # define UT_ID(U) "??"
 #endif
 
+#undef HAVE_UT_HOST	/* needed for Fiwix */
+
 /* If true, attempt to canonicalize hostnames via a DNS lookup. */
 static bool do_lookup;
 
